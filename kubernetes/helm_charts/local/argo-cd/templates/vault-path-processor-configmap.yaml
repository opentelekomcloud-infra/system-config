{{- if and (hasKey .Values "vaultPathProcessor") .Values.vaultPathProcessor.enabled }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ (.Values.vaultPathProcessor.configMapName) | default "vault-path-processor-cm" }}
  namespace: {{ .Release.Namespace | default "argocd" }}
data:
  {{ (.Values.vaultPathProcessor.scriptName) | default "vault-path-processor.sh" }}: |
    #!/bin/bash
    # Vault Path Processor - handles OpenStack and KV paths

    # Read input from stdin
    input=$(cat)

    # Create temporary file for processing
    temp_file="/tmp/template_$$"
    echo "$input" > "$temp_file"

    # Process each line looking for OpenStack paths
    while IFS= read -r line; do
      if [[ "$line" == *"<path:openstack/"* ]]; then
        # Process all OpenStack placeholders in the line
        while [[ "$line" =~ \<path:openstack/([^#]+)#([^>]+)\> ]]; do
          path_part="${BASH_REMATCH[1]}"
          field_part="${BASH_REMATCH[2]}"

          # Get value from OpenStack secrets engine using vault CLI
          if command -v vault >/dev/null 2>&1 && [ -n "$VAULT_TOKEN" ] && [ -n "$VAULT_ADDR" ]; then
            value=$(vault read -field="$field_part" "openstack/$path_part" 2>/dev/null || echo "VAULT_READ_ERROR")
            placeholder="<path:openstack/${path_part}#${field_part}>"
            line="${line//$placeholder/$value}"
          else
            # If vault is not available, leave placeholder as-is
            break
          fi
        done
      fi
      echo "$line"
    done < "$temp_file"

    # Clean up
    rm -f "$temp_file"
{{- end }}
