#!/bin/bash

# OTC Threat Intelligence Updater
# Updates security groups with latest threat intelligence data
# Integrates with Spamhaus, SANS, and AbuseIPDB

set -euo pipefail

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="${SCRIPT_DIR}/../security-groups"
TEMP_DIR="/tmp/otc-threat-intel"
LOG_FILE="/var/log/otc-threat-intel.log"

# Vault configuration
VAULT_ADDR="${VAULT_ADDR:-https://vault.example.com:8200}"
VAULT_TOKEN="${VAULT_TOKEN:-}"

# OTC cloud credentials (from Vault)
OTC_CLOUDS=(
    "otc_vault_448_de_eco_infra"
    "otc_vault_449_de_eco_infra"
    "otc_vault_449_nl_eco_infra"
    "otc_vault_448_de_database"
    "otc_vault_448_de_apimon"
    "otc_vault_448_de_zuul_pool1"
    "otc_vault_448_de_zuul_pool2"
    "otc_vault_448_de_zuul_pool3"
    "otccloudmon-de"
    "otccloudmon-nl"
)

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "${LOG_FILE}"
}

# Error handling
error() {
    log "ERROR: $*"
    exit 1
}

# Check dependencies
check_dependencies() {
    local deps=("curl" "jq" "ansible-playbook" "vault")

    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            error "Required dependency '$dep' not found"
        fi
    done

    log "All dependencies satisfied"
}

# Setup working directory
setup_working_dir() {
    mkdir -p "${TEMP_DIR}"
    cd "${TEMP_DIR}"
    log "Working directory setup: ${TEMP_DIR}"
}

# Get API key from Vault
get_api_key() {
    local vault_path="$1"

    if [[ -z "${VAULT_TOKEN}" ]]; then
        error "VAULT_TOKEN environment variable not set"
    fi

    curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
         "${VAULT_ADDR}/v1/${vault_path}" | \
         jq -r '.data.data.api_key' 2>/dev/null || error "Failed to get API key from Vault"
}

# Download Spamhaus DROP list
download_spamhaus_drop() {
    log "Downloading Spamhaus DROP list..."

    curl -s -o spamhaus_drop.txt \
         "https://www.spamhaus.org/drop/drop.txt" || \
         error "Failed to download Spamhaus DROP list"

    # Parse CIDR blocks (ignore comments)
    grep -v '^;' spamhaus_drop.txt | \
    grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+' | \
    awk '{print $1}' > spamhaus_cidrs.txt

    local count=$(wc -l < spamhaus_cidrs.txt)
    log "Downloaded ${count} Spamhaus DROP entries"
}

# Download SANS Storm Center IPs
download_sans_storm() {
    log "Downloading SANS Storm Center data..."

    curl -s -o sans_storm.json \
         "https://isc.sans.edu/api/sources/attacks/1000/?json" || \
         error "Failed to download SANS Storm Center data"

    # Extract top attacking IPs
    jq -r '.[] | select(.attacks > 10) | .ip' sans_storm.json | \
    head -100 > sans_ips.txt

    local count=$(wc -l < sans_ips.txt)
    log "Downloaded ${count} SANS Storm Center IPs"
}

# Download AbuseIPDB blacklist
download_abuseipdb() {
    log "Downloading AbuseIPDB blacklist..."

    local api_key
    api_key=$(get_api_key "secret/abuseipdb/api_key")

    curl -s -H "Key: ${api_key}" \
         -H "Accept: application/json" \
         -G "https://api.abuseipdb.com/api/v2/blacklist" \
         --data-urlencode "confidenceMinimum=75" \
         --data-urlencode "limit=1000" \
         -o abuseipdb.json || \
         error "Failed to download AbuseIPDB data"

    # Extract IP addresses
    jq -r '.data[].ipAddress' abuseipdb.json > abuseipdb_ips.txt

    local count=$(wc -l < abuseipdb_ips.txt)
    log "Downloaded ${count} AbuseIPDB entries"
}

# Generate security group rules from threat data
generate_security_rules() {
    log "Generating security group rules..."

    # Generate Spamhaus rules
    cat > spamhaus_rules.yaml << 'EOF'
---
# Spamhaus DROP list security group rules
# Auto-generated by threat intelligence updater

spamhaus_drop_rules:
EOF

    while IFS= read -r cidr; do
        cat >> spamhaus_rules.yaml << EOF
  - protocol: "tcp"
    port_range_min: 1
    port_range_max: 65535
    remote_ip_prefix: "${cidr}"
    direction: "ingress"
    description: "Spamhaus DROP - ${cidr}"
EOF
    done < spamhaus_cidrs.txt

    # Generate SANS rules
    cat > sans_rules.yaml << 'EOF'
---
# SANS Storm Center security group rules
# Auto-generated by threat intelligence updater

sans_storm_rules:
EOF

    while IFS= read -r ip; do
        cat >> sans_rules.yaml << EOF
  - protocol: "tcp"
    port_range_min: 1
    port_range_max: 65535
    remote_ip_prefix: "${ip}/32"
    direction: "ingress"
    description: "SANS Storm - ${ip}"
EOF
    done < sans_ips.txt

    # Generate AbuseIPDB rules
    cat > abuseipdb_rules.yaml << 'EOF'
---
# AbuseIPDB security group rules
# Auto-generated by threat intelligence updater

abuseipdb_rules:
EOF

    while IFS= read -r ip; do
        cat >> abuseipdb_rules.yaml << EOF
  - protocol: "tcp"
    port_range_min: 1
    port_range_max: 65535
    remote_ip_prefix: "${ip}/32"
    direction: "ingress"
    description: "AbuseIPDB - ${ip}"
EOF
    done < abuseipdb_ips.txt

    log "Security group rules generated"
}

# Update security group configuration files
update_config_files() {
    log "Updating security group configuration files..."

    # Create backup of current configurations
    local backup_dir="${CONFIG_DIR}/backup-$(date +%Y%m%d-%H%M%S)"
    mkdir -p "${backup_dir}"
    cp "${CONFIG_DIR}"/threat-intelligence-sg.yaml "${backup_dir}/"

    # Update threat intelligence configuration
    cat > "${CONFIG_DIR}/threat-intelligence-sg-updated.yaml" << 'EOF'
---
# Threat Intelligence Security Group Configuration
# Updated automatically by threat intelligence feeds

# Import generated rules
EOF

    # Append generated rules
    cat spamhaus_rules.yaml >> "${CONFIG_DIR}/threat-intelligence-sg-updated.yaml"
    echo "" >> "${CONFIG_DIR}/threat-intelligence-sg-updated.yaml"
    cat sans_rules.yaml >> "${CONFIG_DIR}/threat-intelligence-sg-updated.yaml"
    echo "" >> "${CONFIG_DIR}/threat-intelligence-sg-updated.yaml"
    cat abuseipdb_rules.yaml >> "${CONFIG_DIR}/threat-intelligence-sg-updated.yaml"

    # Apply security group configurations for each cloud
    cat >> "${CONFIG_DIR}/threat-intelligence-sg-updated.yaml" << 'EOF'

# Apply to all OTC clouds
threat_intelligence_security_groups:
EOF

    for cloud in "${OTC_CLOUDS[@]}"; do
        cat >> "${CONFIG_DIR}/threat-intelligence-sg-updated.yaml" << EOF
  - cloud: "${cloud}"
    name: "spamhaus_drop_sg"
    description: "Block Spamhaus DROP list IPs"
    rules: "{{ spamhaus_drop_rules }}"
  - cloud: "${cloud}"
    name: "sans_storm_sg"
    description: "Block SANS Storm Center IPs"
    rules: "{{ sans_storm_rules }}"
  - cloud: "${cloud}"
    name: "abuseipdb_sg"
    description: "Block AbuseIPDB reported IPs"
    rules: "{{ abuseipdb_rules }}"
EOF
    done

    # Replace old configuration with new one
    mv "${CONFIG_DIR}/threat-intelligence-sg-updated.yaml" \
       "${CONFIG_DIR}/threat-intelligence-sg.yaml"

    log "Configuration files updated"
}

# Deploy security groups using Ansible
deploy_security_groups() {
    log "Deploying security groups to OTC clouds..."

    # Create Ansible playbook for deployment
    cat > deploy-threat-intel.yml << 'EOF'
---
- name: Deploy threat intelligence security groups
  hosts: localhost
  gather_facts: false
  vars_files:
    - "../security-groups/threat-intelligence-sg.yaml"

  tasks:
    - name: Deploy security groups
      include_role:
        name: cloud_sg
      vars:
        sg: "{{ item }}"
        state: "present"
      loop: "{{ threat_intelligence_security_groups }}"
      when: threat_intelligence_security_groups is defined
EOF

    # Run Ansible playbook
    if ansible-playbook deploy-threat-intel.yml; then
        log "Security groups deployed successfully"
    else
        error "Failed to deploy security groups"
    fi
}

# Generate statistics report
generate_report() {
    log "Generating threat intelligence report..."

    local spamhaus_count=$(wc -l < spamhaus_cidrs.txt)
    local sans_count=$(wc -l < sans_ips.txt)
    local abuseipdb_count=$(wc -l < abuseipdb_ips.txt)
    local total_count=$((spamhaus_count + sans_count + abuseipdb_count))

    cat > "${SCRIPT_DIR}/threat-intel-report.txt" << EOF
OTC Threat Intelligence Update Report
Generated: $(date)

Summary:
- Spamhaus DROP entries: ${spamhaus_count}
- SANS Storm Center IPs: ${sans_count}
- AbuseIPDB entries: ${abuseipdb_count}
- Total blocked IPs/networks: ${total_count}

Deployment Status: SUCCESS
Next update: $(date -d '+1 hour')

Applied to clouds:
$(printf '- %s\n' "${OTC_CLOUDS[@]}")
EOF

    log "Report generated: ${SCRIPT_DIR}/threat-intel-report.txt"
}

# Cleanup temporary files
cleanup() {
    rm -rf "${TEMP_DIR}"
    log "Cleanup completed"
}

# Main execution
main() {
    log "Starting OTC threat intelligence update"

    # Trap for cleanup on exit
    trap cleanup EXIT

    check_dependencies
    setup_working_dir

    # Download threat intelligence data
    download_spamhaus_drop
    download_sans_storm
    download_abuseipdb

    # Process and deploy
    generate_security_rules
    update_config_files
    deploy_security_groups

    # Generate report
    generate_report

    log "OTC threat intelligence update completed successfully"
}

# Script options
case "${1:-}" in
    --dry-run)
        log "DRY RUN MODE - No changes will be applied"
        # Set dry run flags here
        main
        ;;
    --help|-h)
        cat << EOF
OTC Threat Intelligence Updater

Usage: $0 [OPTIONS]

OPTIONS:
    --dry-run    Run without making changes
    --help       Show this help message

Environment Variables:
    VAULT_ADDR   Vault server address
    VAULT_TOKEN  Vault authentication token

Examples:
    $0                    # Normal run
    $0 --dry-run         # Test run without changes
EOF
        exit 0
        ;;
    *)
        main
        ;;
esac
